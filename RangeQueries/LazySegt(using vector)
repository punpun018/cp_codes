class LazySegmentTree
{
private:
    int n;
    vector<int> tree, lazy;

    void build(const vector<int> &a, int v, int tl, int tr)
    {
        if (tl == tr)
        {
            tree[v] = a[tl];
        }
        else
        {
            int tm = (tl + tr) / 2;
            build(a, v * 2, tl, tm);
            build(a, v * 2 + 1, tm + 1, tr);
            tree[v] = max(tree[v * 2], tree[v * 2 + 1]);
        }
    }

    void push(int v)
    {
        tree[v * 2] += lazy[v];
        lazy[v * 2] += lazy[v];
        tree[v * 2 + 1] += lazy[v];
        lazy[v * 2 + 1] += lazy[v];
        lazy[v] = 0;
    }

    void update(int v, int tl, int tr, int l, int r, int addend)
    {
        if (l > r)
            return;
        if (l == tl && r == tr)
        {
            tree[v] += addend;
            lazy[v] += addend;
        }
        else
        {
            push(v);
            int tm = (tl + tr) / 2;
            update(v * 2, tl, tm, l, min(r, tm), addend);
            update(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, addend);
            tree[v] = max(tree[v * 2], tree[v * 2 + 1]);
        }
    }

    int query(int v, int tl, int tr, int l, int r)
    {
        if (l > r)
            return intmin;
        if (l == tl && r == tr)
            return tree[v];
        push(v);
        int tm = (tl + tr) / 2;
        return max(
            query(v * 2, tl, tm, l, min(r, tm)),
            query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));
    }

public:
    LazySegmentTree(int size)
    {
        n = size;
        tree.assign(4 * n, 0);
        lazy.assign(4 * n, 0);
    }

    void build(const vector<int> &a)
    {
        build(a, 1, 0, n - 1);
    }

    void update(int l, int r, int addend)
    {
        update(1, 0, n - 1, l, r, addend);
    }

    int query(int l, int r)
    {
        return query(1, 0, n - 1, l, r);
    }
};
